---
title: "aula_08_08"
format: html
editor: visual
---

## Desafio

```{r}
#install.packages("rbcb")

require(rbcb)
require(ggplot2)
SelicD <- get_series(11, start_date = "2025-01-01", end_date ="2025-06-29") 
SelicD; View(SelicD); print(tail(SelicD))
plot.ts(SelicD$'11', type="l", col="red", lw=3)

```

```{r}

#install.packages("ggplot2")
{
  colnames(SelicD) <- c("data", "selicdiaria")
  
  graficoselic <- ggplot(data = SelicD, aes(x = data, y = selicdiaria)) +
  geom_line(color = "red", linewidth = 1.2) +  
  labs(
    title = "Evolução da Taxa Selic Diária",
    subtitle = paste("Período de", format(as.Date("2025-01-01"), "%d/%m/%Y"), "a", format(as.Date("2025-06-29"), "%d/%m/%Y")),
    x = "Data",
    y = "Taxa de Juros (% a.d.)",
    caption = "Fonte: Banco Central do Brasil (via pacote rbcb)"
  ) +
  theme_minimal() + 
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"), 
    plot.subtitle = element_text(hjust = 0.5) 
  )
# Exibe o gráfico gerado
print(graficoselic)

}
```

You can add options to executable code like this

```{r}

library(quantmod)
library(PerformanceAnalytics)
library(PortfolioAnalytics)
library(DEoptim)
library(ROI)
library(ROI.plugin.quadprog)
library(tidyverse)

# Lista dos ativos (os seus)
ativos <- c("LWSA3.SA", "ELET6.SA", "ITSA4.SA", "RENT3.SA", "BRFS3.SA")

# Período de análise
data_inicio <- as.Date("2025-04-01")
data_fim <- as.Date("2025-06-29")

getSymbols(ativos, from = data_inicio, to = data_fim)

# Extrair preços de fechamento ajustado
precos <- do.call(merge, lapply(ativos, function(x) Ad(get(x))))
colnames(precos) <- ativos
retornos <- na.omit(Return.calculate(precos, method = "log"))
# Inicializa portfólio
port <- portfolio.spec(assets = ativos)

# Adiciona restrições básicas
port <- add.constraint(port, type = "full_investment")
port <- add.constraint(port, type = "long_only")

# Adiciona objetivo: retorno-alvo (exemplo: 0.001 por dia)
retorno_alvo <- 0.001
port <- add.constraint(port, type = "return", return_target = retorno_alvo)

# Adiciona objetivo de minimizar risco
port <- add.objective(port, type = "risk", name = "StdDev")

# Otimização
resultado <- optimize.portfolio(retornos, portfolio = port, optimize_method = "ROI")

# Pesos ótimos
print(extractWeights(resultado))

```

## Cálculo dos Retornos

```{r}
Basico<-data.frame(na.omit(merge(lwsa3, elet6, itsa4, rent3, brfs3)));Basico
names(Basico)<-c("lwsa3", "elet6", "itsa4", "rent3", "brfs3");Basico;length(brfs3)
write.table(Basico,file="Basico.txt")

dados<-read.table("Basico.txt", head=T);dados
dados <- timeSeries(dados)
dados

Retornos<-returns(dados);Retornos
View(data.frame(Retornos))
require(fPortfolio)

fronteira<-portfolioFrontier(Retornos);fronteira
frontierPlot(fronteira, auto=F)
points(0.0365,-0.0027,pch=19, cex=1.5, col="green")
points(0.0203,-0.0002,pch=19, cex=1.5, col="green")
points(0.0144,0.0049 ,pch=19, cex=1.5, col="green")
points(0.0237,0.0074,pch=19, cex=1.5,col="red")

```

## Retorno-Alvo da Carteira

```{r}
Basico<-data.frame(na.omit(merge(lwsa3, elet6, itsa4, rent3, brfs3)));Basico
names(Basico)<-c("lwsa3", "elet6", "itsa4", "rent3", "brfs3");Basico;length(brfs3)
write.table(Basico,file="Basico.txt")

dados<-read.table("Basico.txt", head=T);dados
dados <- timeSeries(dados)
dados

Retornos<-returns(dados);Retornos
View(data.frame(Retornos))
require(fPortfolio)

fronteira<-portfolioFrontier(Retornos);fronteira
frontierPlot(fronteira, auto=F)
points(0.0365,-0.0027,pch=19, cex=1.5, col="green")
points(0.0203,-0.0002,pch=19, cex=1.5, col="green")
points(0.0144,0.0049 ,pch=19, cex=1.5, col="green")
points(0.0237,0.0074,pch=19, cex=1.5, col="red")

```

## Média

```{r}
library(tseries)


# Datas de início e fim
dataini <- as.Date("2025-04-01")
datafim <- as.Date("2025-06-29")

# Vetor com os tickers
tickers <- c("lwsa3.sa", "elet6.sa", "itsa4.sa", "rent3.sa", "brfs3.sa")

# Lista para armazenar os preços históricos
precos <- list()

# Baixando os dados e removendo NAs
for (ticker in tickers) {
  serie <- get.hist.quote(ticker, quote = "Close", start = dataini, end = datafim)
  serie <- na.omit(serie)
  precos[[ticker]] <- serie
}

# Função para calcular média e desvio padrão
estatisticas <- lapply(precos, function(x) {
  c(Media = mean(x), DesvioPadrao = sd(x))
})

# Exibindo resultados
estatisticas
estat_df <- do.call(rbind, estatisticas)
estat_df
```

## Ativo Livro de Risco

```{r}

#install.packages("ROI")
#install.packages("ROI.plugin.quadprog")
#install.packages("ROI.plugin.glpk")


library(PortfolioAnalytics)
library(DEoptim)
library(ROI)
library(ROI.plugin.quadprog)

# Criar especificação do portfólio
port_spec <- portfolio.spec(assets = colnames(Retornos))
port_spec <- add.constraint(port_spec, type = "full_investment")  # soma dos pesos = 1
port_spec <- add.constraint(port_spec, type = "long_only")        # sem venda a descoberto
port_spec <- add.objective(port_spec, type = "risk", name = "var")  # minimizar variância
port_spec <- add.objective(port_spec, type = "return", name = "mean")  # maximizar retorno

# Otimizar e gerar a fronteira
fronteira <- create.EfficientFrontier(R = Retornos, portfolio = port_spec,
                                      type = "mean-StdDev", n.portfolios = 50)

fronteira_df <- as.data.frame(fronteira)
plot(fronteira_df$StdDev, fronteira_df$mean,
     type = "l", lwd = 2, col = "blue",
     xlab = "Risco (Desvio-Padrão)",
     ylab = "Retorno Esperado",
     main = "Fronteira Eficiente (Markowitz)")



```

{{< >}} #install.packages("ROI") #install.packages("ROI.plugin.quadprog") #install.packages("ROI.plugin.glpk")

library(PortfolioAnalytics) library(DEoptim) library(ROI) library(ROI.plugin.quadprog)

# Criar especificação do portfólio

port_spec \<- portfolio.spec(assets = colnames(Retornos)) port_spec \<- add.constraint(port_spec, type = "full_investment") \# soma dos pesos = 1 port_spec \<- add.constraint(port_spec, type = "long_only") \# sem venda a descoberto port_spec \<- add.objective(port_spec, type = "risk", name = "var") \# minimizar variância port_spec \<- add.objective(port_spec, type = "return", name = "mean") \# maximizar retorno

# Otimizar e gerar a fronteira

fronteira \<- create.EfficientFrontier(R = Retornos, portfolio = port_spec, type = "mean-StdDev", n.portfolios = 50)

fronteira_df \<- as.data.frame(fronteira) plot(fronteira_df$StdDev, fronteira_df$mean, type = "l", lwd = 2, col = "blue", xlab = "Risco (Desvio-Padrão)", ylab = "Retorno Esperado", main = "Fronteira Eficiente (Markowitz)")
